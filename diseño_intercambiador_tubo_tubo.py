# -*- coding: utf-8 -*-
"""Diseño Intercambiador Tubo-Tubo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Lzh6ljzsNG--LLCksWAJGW54p0tByqob

# Diseño de un intercambiador de calor tipo tubo en tubo

El propósito de este modelo iterador es facilitar el **prediseño de un intercambiador de calor tipo tubo en tubo**, muy usado en industrias en general (ej: bodegas en enfriamiento de mosto, petroquímca en calentamento de crudo, etc.), como criterio de metodo de diseño y calculo del tamaño necesario de un intercambiador, siguiendo la secuencia de cálculo propuesta por el Ing. Cao.

El programa permitirá al usuario introducir diversas variables para el prediseño del intercambiador, y luego ofrecerá la opción de modificar dichas variables. Esto permitirá observar de manera interactiva cómo las alteraciones en la geometría afectan los resultados del diseño, ofreciendo un criterio estandar de calculo para el dimensionamiento, seleccion y/o optimización final del equipo dado.

**POSIBLES MODULOS Y ORGANIZACION PROPUESTA**

a) Módulo de Datos de Entrada:

FUNCIÓN: Manejar todo lo que el usuario ingresa (temperaturas, fluidos, etc.).

CÓMO: Si falta un dato (ej: densidad), este módulo decide si usar CoolProp, una fórmula de gases ideales, o pedírselo al usuario.

EJEMPLO PRÁCTICO: Una lista de "datos obligatorios" y "datos opcionales". Si el usuario no pone la densidad, automáticamente se calcula.

b) Módulo de Simulación (Corazón del Cálculo):

FUNCIÓN: Contiene las fórmulas y cálculos del intercambiador (lo que ya tenés hecho).

DETALLE: Que sea independiente de cómo se ingresaron los datos. Solo recibe números y devuelve resultados.

c) Módulo de Optimización:

FUNCIÓN: Cuando el diseño no cumple, aquí se ajustan parámetros (diámetros, velocidades) y se reinicia la simulación.

TRUCO: Usá un bucle (como un "repetir hasta que funcione") que pruebe combinaciones. Guardá cada intento en una tabla (como un Excel interno) para mostrar después cómo evolucionó el diseño.

d) Módulo de Visualización/Historial:

FUNCIÓN: Graficar resultados y mostrar el histórico de optimizaciones.

EJEMPLO: Después de cada iteración, guardá los parámetros clave y los resultados en una lista. Luego, usá esa lista para hacer gráficos de "cómo mejoró el diseño".

e) Módulo de Interfaz Gráfica (GUI):

FUNCIÓN: Permite cargar datos en campos tipo formulario y elegir opciones (tuberías vs. caños, etc.).

# Detalle y carga de Librerias necesarias
"""

!pip install pint
import numpy as np
import pandas as pd
import math
import os
from pathlib import Path
# ================================================================================================================
# CONFIGURACIÓN INICIAL - REGISTRO DE UNIDADES
# ================================================================================================================
from pint import UnitRegistry
u = UnitRegistry()
Q = u.Quantity  # Definimos el alias Q para u.Quantity (opcional, para consistencia)

# Instalar e importar lo necesario para el calculo de diametros (usa cañerias!)
!pip install fluids
import fluids
from fluids.piping import nearest_pipe
from fluids import piping
from fluids.friction import friction_factor

import pickle

"""# Ingreso de valores - HOJA TEMA

## funciones para ingresos de datos
"""

# =====================================================================
# FUNCIONES PARA MANEJO DE DATOS
# =====================================================================

""" La intencion es que los datos cargados queden guardados en un pickle
de tal manera que no tengan que cargarse en cada iteracion. Desventaja: se
pierde cuando cerramos el kernel"""

def guardar_datos(df_caliente, df_frio):
    """Guarda los DataFrames completos en archivos pickle"""
    df_caliente.to_pickle('fluido_caliente.pkl')
    df_frio.to_pickle('fluido_frio.pkl')

def cargar_datos():
    """Carga los DataFrames desde archivos pickle"""
    try:
        df_caliente = pd.read_pickle('fluido_caliente.pkl')
        df_frio = pd.read_pickle('fluido_frio.pkl')
        return df_caliente, df_frio
    except FileNotFoundError:
        return None, None

def extraer_variables(df, tipo_fluido):
    """Extrae y convierte variables con unidades desde DataFrame"""
    datos = {}

    # Mapeo de columnas a unidades
    unidades = {
        'caliente': {
            'Temperatura entrada fluido caliente (T1)': 'degC',
            'Temperatura salida fluido caliente (T2)': 'degC',
            'Caudal másico fluido caliente (Wh)': 'kg/hour',
            'Capacidad calorífica fluido caliente (cp_h)': 'kcal/(kg*delta_degC)',
            'Presión fluido caliente (presion_h)': 'atm',
            'Masa molar fluido caliente (masa_molar_h)': 'g/mole',
            'Viscosidad fluido caliente (visc_h)': 'cP',
            'Conductividad térmica fluido caliente (k_h)': 'kcal/(h*m*degC)'
        },
        'frio': {
            'Temperatura entrada fluido frío (t1)': 'degC',
            'Temperatura salida fluido frío (t2)': 'degC',
            'Caudal másico fluido frío (Wc)': 'kg/hour',
            'Capacidad calorífica fluido frío (cp_c)': 'kcal/(kg*delta_degC)',
            'Densidad fluido frío (dens_c)': 'kg/m**3',
            'Viscosidad fluido frío (visc_c)': 'cP',
            'Conductividad térmica fluido frío (k_c)': 'kcal/(h*m*degC)'
        }
    }

    for columna, unidad in unidades[tipo_fluido].items():
        datos[columna.split(' ')[-1].replace('(', '').replace(')', '')] = Q(df[columna].iloc[0], unidad)

    return datos

"""## ingreso de datos"""

# =====================================================================
# PROGRAMA PRINCIPAL
# =====================================================================

# Cargar o ingresar datos
df_caliente, df_frio = cargar_datos()

if df_caliente is None or df_frio is None:
    print("\nNo se encontraron datos guardados. Ingrese los parámetros:")

    # Ingreso de datos para fluido caliente
    nombre_fluido_caliente = input("\nIngrese el nombre del fluido caliente: ").strip().upper()
    datos_caliente = {
        'Temperatura entrada fluido caliente (T1)': float(input("T1 (°C): ")),
        'Temperatura salida fluido caliente (T2)': float(input("T2 (°C): ")),
        'Caudal másico fluido caliente (Wh)': float(input("Wh (kg/h): ")),
        'Capacidad calorífica fluido caliente (cp_h)': float(input("cp_h (kcal/(kg·°C)): ")),
        'Presión fluido caliente (presion_h)': float(input("presion_h (atm): ")),
        'Masa molar fluido caliente (masa_molar_h)': float(input("masa_molar_h (g/mole): ")),
        'Viscosidad fluido caliente (visc_h)': float(input("visc_h (cP): ")),
        'Conductividad térmica fluido caliente (k_h)': float(input("k_h (kcal/(h·m·°C)): "))
    }

    # Ingreso de datos para fluido frío
    nombre_fluido_frio = input("\nIngrese el nombre del fluido frío: ").strip().upper()
    datos_frio = {
        'Temperatura entrada fluido frío (t1)': float(input("t1 (°C): ")),
        'Temperatura salida fluido frío (t2)': float(input("t2 (°C): ")),
        'Caudal másico fluido frío (Wc)': float(input("Wc (kg/h): ")),
        'Capacidad calorífica fluido frío (cp_c)': float(input("cp_c (kcal/(kg·°C)): ")),
        'Densidad fluido frío (dens_c)': float(input("dens_c (kg/m³): ")),
        'Viscosidad fluido frío (visc_c)': float(input("visc_c (cP): ")),
        'Conductividad térmica fluido frío (k_c)': float(input("k_c (kcal/(h·m·°C)): "))
    }

    # Crear DataFrames
    df_caliente = pd.DataFrame([datos_caliente])
    df_frio = pd.DataFrame([datos_frio])

    # Mostrar resumen
    print(f"\nResumen - Fluido Caliente ({nombre_fluido_caliente}):")
    print(df_caliente)
    print(f"\nResumen - Fluido Frío ({nombre_fluido_frio}):")
    print(df_frio)

    # Guardar datos
    guardar_datos(df_caliente, df_frio)
    print("\nDatos guardados correctamente para próximas ejecuciones.")
else:
    print("Datos cargados correctamente.")
    print("\nTabla de Fluido Caliente:")
    print(df_caliente)
    print("\nTabla de Fluido Frío:")
    print(df_frio)

"""## extraccion y conversion de variables"""

# =====================================================================
# EXTRACCIÓN Y CONVERSIÓN DE VARIABLES
# =====================================================================

# Extraer variables con unidades para fluidos
fluido_caliente = extraer_variables(df_caliente, 'caliente')
fluido_frio = extraer_variables(df_frio, 'frio')

# Asignación a variables (opcional, manteniendo compatibilidad)
T1 = fluido_caliente['T1']
T2 = fluido_caliente['T2']
Wh = fluido_caliente['Wh']
cp_h = fluido_caliente['cp_h']
presion_h = fluido_caliente['presion_h']
masa_molar_h = fluido_caliente['masa_molar_h']
visc_h = fluido_caliente['visc_h']
k_h = fluido_caliente['k_h']

t1 = fluido_frio['t1']
t2 = fluido_frio['t2']
Wc = fluido_frio['Wc']
cp_c = fluido_frio['cp_c']
dens_c = fluido_frio['dens_c']
visc_c = fluido_frio['visc_c']
k_c = fluido_frio['k_c']

"""# no modificar - dataframe historico

# Cargar datos existentes o inicializar (como ya lo tienes)
fluido_caliente_data, fluido_frio_data = cargar_datos()

# Inicializar el DataFrame histórico VACÍO
columnas_historico = [
    'Iteración', 'Longitud (m)', 'Diámetro_int (m)', 'Diámetro_ext (m)', 'N_pasos',
    'Área (m²)', 'Q (kcal/h)', 'U_global (kcal/h·m²·°C)', 'DTML (°C)',
    'h_i (kcal/h·m²·°C)', 'h_io (kcal/h·m²·°C)', 'h_o (kcal/h·m²·°C)',
    'v_caliente (m/s)', 'Re_caliente', 'ΔP_caliente (bar)', 'Flujo_caliente',
    'v_frio (m/s)', 'Re_frio', 'ΔP_frio (bar)', 'Flujo_frio',
    'Cumple_ΔP', 'Cumple_Área'
]
df_historico = pd.DataFrame(columns=columnas_historico)

# SECCION PRINCIPAL - METODO COEFICIENTES

## CAPACIDAD DEL EQUIPO Y DTML
"""

# ================================================================================================================
# CÁLCULO DE CALOR INTERCAMBIADO - CAPACIDAD DEL EQUIPO
# ================================================================================================================

Qh = Wh * cp_h * (T1 - T2)                     # Calor transferido por fluido caliente [kcal/h]
Qc = Wc * cp_c * (t2 - t1)                     # Calor absorbido por fluido frío [kcal/h]
Q_prom = (Qh + Qc) / 2                        # Calor promedio [kcal/h]

print(f"Calor entregado por el fluido caliente (Qh): {Qh.to('kcal/hour'):.2f}")
print(f"Calor absorbido por el fluido frío (Qc): {Qc.to('kcal/hour'):.2f}")
print()
print(f"----- CAPACIDAD DEL EQUIPO (Q_prom): {Q_prom.to('kcal/hour'):.2f}")

print()
# Chequeo de balance térmico
if abs(Qh.magnitude - Qc.magnitude) / Qh.magnitude < 0.05:
    print("Balance térmico: OK")
else:
    print("Balance térmico: ERROR")

#=================================================================================================================
# CALCULO DEL DTML
#=================================================================================================================

#DIFERENCIA MEDIA DE TEMPERATURA
DeltaT_h = T1 - t2
DeltaT_c = T2 - t1

def dif_logmean(DeltaT_h, DeltaT_c):
    if DeltaT_h == DeltaT_c:
        return DeltaT_h
    else:
        return (DeltaT_h - DeltaT_c) / np.log(DeltaT_h / DeltaT_c)

# Calcular la diferencia media de temperatura
dif_media_temperatura = dif_logmean(DeltaT_h, DeltaT_c)

# Redondear el resultado a 2 decimales y obtener el valor numérico sin unidades
dif_media_temperatura_redondeada = round(dif_media_temperatura.magnitude, 1)

# Imprimir el resultado redondeado con el símbolo °C
print()
print("Diferencia media de temperatura: ", dif_media_temperatura_redondeada, "°C")

"""## Definir el fluido que circulará por el interior de tubos"""

# Solicitar configuración de flujo
print("\n--- Configuración del Intercambiador ---")
fluido_interior = input("¿Qué fluido circulará por el interior del tubo? (frio/caliente): ").strip().lower()

# Validar entrada
while fluido_interior not in ["frio", "caliente"]:
    print("¡Error! Ingrese 'frio' o 'caliente'.")
    fluido_interior = input("¿Qué fluido circulará por el interior del tubo? (frio/caliente): ").strip().lower()

# Asignar DataFrames según selección
if fluido_interior == "caliente":
    df_interior = df_caliente
    df_exterior = df_frio
else:
    df_interior = df_frio
    df_exterior = df_caliente

print(f"\nFluido en tubo interior: {fluido_interior.upper()}")

"""## Velocidad de tubo interior y longitud de horquilla"""

# Pedir parámetros de diseño
try:
    v_interior = float(input("\nIngrese la velocidad deseada en el tubo interior (m/s): "))
    longitud_tubos = Q(float(input("Ingrese la longitud de los tubos (m): ")), 'm')  # Usando Q para dimensión de metros
except ValueError:
    print("¡Error! Ingrese valores numéricos.")
    # Puedes agregar un bucle para reintentar

"""## Calculo de diametro de tubo interior"""

# ================================================================================================================
# CÁLCULO DEL TUBO INTERIOR (según fluido seleccionado y velocidad ingresada por el usuario)
# ================================================================================================================

# Usamos las variables cargadas desde pickle, según fluido interior seleccionado
if fluido_interior == "frio":
    W_fluido_interior = Wc.to('kg/s')          # Caudal másico del fluido frío (convertido a kg/s)
    dens_fluido_interior = dens_c              # Densidad del fluido frío (ya está en kg/m³)
else:
    W_fluido_interior = Wh.to('kg/s')          # Caudal másico del fluido caliente
    dens_fluido_interior = Q((presion_h * masa_molar_h) / (0.082057 * (T1.to('K').magnitude), 'kg/m**3'))  # Densidad gas ideal (ejemplo)

# Velocidad ingresada por el usuario (v_interior)
V = Q(v_interior, 'm/s')

# Cálculo del área de flujo y diámetro interno
W_volumetrico = W_fluido_interior / dens_fluido_interior  # Caudal volumétrico [m³/s]
A_flow = W_volumetrico / V                                # Área de flujo requerida [m²]
D_int_estimado = Q(math.sqrt(4 * A_flow.magnitude / math.pi), 'm')  # Diámetro estimado

print(f"Área de flujo requerida: {A_flow.to('cm**2'):.2f}")
print(f"Diámetro interno estimado: {D_int_estimado.to('mm'):.2f}")

# Selección del tubo comercial más cercano (schedule 40)
NPS, Di, Do, t = nearest_pipe(Di=D_int_estimado.magnitude, schedule='40')

# Asignación de valores corregidos
dint_tubo_interior = Q(Di, 'm')
dext_tubo_interior = Q(Do, 'm')
velocidad_corregida = V * (D_int_estimado / dint_tubo_interior) ** 2

"""
# Actualizar DataFrame histórico
df_historico.loc[df_historico.index[-1], 'Diámetro_int (m)'] = dint_tubo_interior.magnitude
df_historico.loc[df_historico.index[-1], 'Diámetro_ext (m)'] = dext_tubo_interior.magnitude
df_historico.loc[df_historico.index[-1], 'v_interior (m/s)'] = velocidad_corregida.magnitude

"""

# Resultados
print("\n--- Tubo interior seleccionado ---")
print(f"NPS: {NPS} pulgadas (Schedule 40)")
print(f"Diámetro interno real: {dint_tubo_interior.to('mm'):.2f}")
print(f"Diámetro externo real: {dext_tubo_interior.to('mm'):.2f}")
print(f"Velocidad corregida: {velocidad_corregida.to('m/s'):.2f}")

"""## Seleccion de diámetro de tubo exterior"""

# ================================================================================================================
# INICIALIZACIÓN GLOBAL
# ================================================================================================================
seleccion_tubo_exterior = {}  # Diccionario donde se guardará la selección

# ================================================================================================================
# TABLA DE DIÁMETROS EXTERIORES COMPATIBLES
# ================================================================================================================
TABLA_INTERCAMBIADOR = {
    0.75: [2, 2.5, 3, 4],    # 3/4" interno
    1:    [2, 2.5, 3, 4],    # 1" interno
    1.25: [2, 2.5, 3, 4],    # 1-1/4" interno
    1.5:  [3, 4],            # 1-1/2" interno
    2:    [3, 4],            # 2" interno
    2.5:  [4],               # 2-1/2" interno
    3:    [4]                # 3" interno
}

# ================================================================================================================
# FUNCIÓN PARA OBTENER DIÁMETROS EXTERIORES COMPATIBLES
# ================================================================================================================
def obtener_exteriores_compatibles(diam_interior):
    """Obtiene diámetros exteriores compatibles para un diámetro interior dado."""
    diam_pulg = diam_interior.to('inch').magnitude
    diametros_tabla = sorted(TABLA_INTERCAMBIADOR.keys())

    for d_int in diametros_tabla:
        if d_int >= diam_pulg:
            return d_int, TABLA_INTERCAMBIADOR[d_int]

    return diametros_tabla[-1], TABLA_INTERCAMBIADOR[diametros_tabla[-1]]

# ================================================================================================================
# FUNCIÓN PARA SELECCIÓN INTERACTIVA DEL TUBO EXTERIOR
# ================================================================================================================
def seleccion_interactiva_tubo_exterior(dint_tubo_interior, dext_tubo_interior):
    """Permite al usuario seleccionar interactivamente el tubo exterior."""
    # Obtener diámetro superior inmediato y compatibles
    d_int_tabla, exteriores_compatibles = obtener_exteriores_compatibles(dint_tubo_interior)

    print(f"\nPara un tubo interior de {dint_tubo_interior.to('inch'):.2f~P} ({dint_tubo_interior.to('mm'):.2f~P})")
    print(f"Diámetros exteriores disponibles según tabla: {exteriores_compatibles} pulgadas")

    # Mostrar menú de selección
    while True:
        try:
            print("\nOpciones disponibles:")
            # Iterate using ASCII for letters A, B, C...
            for i, size in enumerate(exteriores_compatibles):
                print(f"{chr(ord('A') + i)}. {size}\"")

            # Get letter input and convert to index
            seleccion = input("\nSeleccione la letra correspondiente al diámetro exterior deseado: ").upper()

            if 'A' <= seleccion <= chr(ord('A') + len(exteriores_compatibles) - 1):
                nps_exterior = exteriores_compatibles[ord(seleccion) - ord('A')]
                break
            else:
                print(f"¡Error! Por favor ingrese una letra entre A y {chr(ord('A') + len(exteriores_compatibles) - 1)}")
        except ValueError:
            print("¡Error! Ingrese solo la letra correspondiente a la opción")

    # Obtener dimensiones reales del tubo exterior seleccionado
    _, di_ext, do_ext, t_ext = nearest_pipe(NPS=nps_exterior, schedule='40')

    # Convertir a Quantity
    dext_tubo_exterior = Q(do_ext, 'm')
    dint_tubo_exterior = Q(di_ext, 'm')
    espesor_exterior = Q(t_ext, 'm')

    # Calcular diámetro equivalente térmico
    diam_equiv_termico = (dint_tubo_exterior**2 - dext_tubo_interior**2) / dint_tubo_exterior

    # Mostrar resultados de la selección
    print("\n" + "="*50)
    print("RESUMEN DE LA SELECCIÓN")
    print("="*50)
    print(f"Tubo interior: {dint_tubo_interior.to('mm'):.2f~P}")
    print(f"Tubo exterior seleccionado: {nps_exterior}\"")
    print(f"Diámetro exterior real: {dext_tubo_exterior.to('mm'):.2f~P}")
    print(f"Diámetro interior real: {dint_tubo_exterior.to('mm'):.2f~P}")
    print(f"Espesor de pared: {espesor_exterior.to('mm'):.2f~P}")
    print(f"Diámetro equivalente térmico: {diam_equiv_termico.to('mm'):.2f~P}")

    return dext_tubo_exterior, dint_tubo_exterior, espesor_exterior, diam_equiv_termico

# ================================================================================================================
# EJECUCIÓN PRINCIPAL
# ================================================================================================================
if __name__ == "__main__":
    # Valores de ejemplo (reemplazar con tus valores reales)
    dint_tubo_interior = Q(23.6, 'mm')  # Diámetro interior calculado
    dext_tubo_interior = Q(26.67, 'mm') # Diámetro exterior del tubo interior

    # Solo una vez: selección interactiva, guardar en diccionario
    dext, dint_ext, esp_ext, diam_eq = seleccion_interactiva_tubo_exterior(dint_tubo_interior, dext_tubo_interior)

    seleccion_tubo_exterior.update({
        "dext_tubo_exterior": dext,
        "dint_tubo_exterior": dint_ext,
        "espesor_exterior": esp_ext,
        "diam_equiv_termico": diam_eq
    })

    # Acceso a los valores seleccionados para cálculos posteriores
    dext_tubo_exterior = seleccion_tubo_exterior["dext_tubo_exterior"]
    dint_tubo_exterior = seleccion_tubo_exterior["dint_tubo_exterior"]
    espesor_exterior = seleccion_tubo_exterior["espesor_exterior"]
    diam_equiv_termico = seleccion_tubo_exterior["diam_equiv_termico"]

# Cálculo de área de flujo exterior
Area_flujo_ext = ((dint_tubo_exterior)**2 - (dint_tubo_interior)**2) * math.pi / 4
print("Área de flujo exterior:", Area_flujo_ext.to('cm²'))

# Promedio de temperaturas para el gas caliente
Th_prom = Q((T1.magnitude + T2.magnitude) / 2, "degC").to("K")

# Constante universal de los gases en J/(mol·K) (equivale a Pa·m³/(mol·K))
R = Q(0.082, "l*atm/(K*mol)")

# Determinación de la densidad del gas de entrada
dens_h = Q((presion_h * masa_molar_h) / (R * Th_prom)).to("kg/m**3")
print("Densidad del gas caliente:", dens_h)

# Velocidad del gas en el tubo exterior
veloc_ext = (Wh.to('kg/s') / dens_h) / Area_flujo_ext
print("Velocidad del gas (m/s):", veloc_ext.to('m/s'))

"""## COEFICIENTE LADO TUBO INTERIOR"""

# TUBO INTERIOR - por el interior del tubo interior circula el agua de enfriamiento

visc_c_SI  = visc_c.to("kg/(m*s)")
k_c_SI = k_c.to("kcal/(s*m*delta_degC)")

# NUMEROS ADIMENSIONALES ==========================================
# Numero de reynolds para el fluido que circula por el tubo interior
Re_int = (dens_c * velocidad_corregida * dint_tubo_interior.to("m")) / visc_c_SI
print ("Numero de reynolds interior tubos: ", Re_int)

#Numero de prandtl para el fluido que circula por el tubo interior
Pr_int = cp_c * visc_c_SI / k_c_SI
print ("Numero de Pr:",Pr_int)

#numero de nusselt para el fluido que circula por el tubo interior
Nu_int = 0.023 * (Re_int ** 0.8) * (Pr_int ** 0.33)
print ("numero de nusselt: ", Nu_int)

#===============================================
# COEFICIENTE INTERIOR REFERIDO AL AREA EXTERIOR
# =============================================

hio = Nu_int * k_c / dext_tubo_interior.to("m")
print ("Coeficiente interior referido al area exterior: ", hio)

"""## COEFICIENTE LADO TUBO EXTERIOR"""

# TUBO EXTERIOR - por el interior del tubo exterior circula el fluido caliente

visc_h = Q(0.012, "cP")
k_h = Q(0.1042, "kcal/(h*m*°C)")
visc_h_SI = visc_h.to("kg/(m*s)")
k_h_SI = k_h.to("kcal/(s*m*delta_degC)")

# NUMEROS ADIMENSIONALES ==========================================
# Numero de reynolds para el fluido que circula por el tubo interior
Re_ext = (dens_h * veloc_ext * diam_equiv_termico) / visc_h_SI
print ("El NRe para el fluido caliente es: ", Re_ext)

#Numero de prandtl para el fluido que circula por el tubo exterior
Pr_ext = (cp_h * visc_h_SI) / k_h_SI
print ("El numero de Pr para el fluido caliente: ", Pr_ext)

#numero de nusselt para el fluido que circula por el tubo exterior
Nu_ext = 0.023 * (Re_ext ** 0.8) * (Pr_ext ** 0.33)
print ("Numero de nusselt fluido caliente: ", Nu_ext)

#===============================================
# COEFICIENTE EXTERIOR
# =============================================

ho = Nu_ext * k_h / diam_equiv_termico  # ✅ Usando parámetros del fluido caliente
print ("Coeficiente exterior: ", ho)

# Resistencias de ensuciamiento interior y exterior - Datos de la hoja de cálculo
Res_ens_int = Q (0.0004, "m**2*delta_degC*h/kcal")
Res_ens_ext = Q (0.0003, "m**2*delta_degC*h/kcal")
print (Res_ens_int)
print (Res_ens_ext)

#Coeficiente global de intercambio

coef_global_U = 1 / (1/hio + 1/ho + Res_ens_ext + Res_ens_int)
print ("Coeficiente global de intercambio térmico :", coef_global_U)

#Area requerida por cálculo térmico


Area_req = Q_prom / (coef_global_U * dif_media_temperatura)

print ("Area requerida :", Q(round(Area_req,2),"m**2"))

print ("Long tubos en metros: ",(Q(round(longitud_tubos, 3), 'meters')))   #imprime long (M)redondeada

#==============================================================================
#AREA DE TRANSFERENCIA TERMICA DISPONIBLE POR HORQUILLA
# ============================================================================

Area_transf_disp_horquilla = u.Quantity(math.pi * dext_tubo_interior.to("m") * 2 * longitud_tubos)
print (longitud_tubos)

print("area de transferencia disponible por horquilla: ", Area_transf_disp_horquilla)

print (dif_media_temperatura)
print (hio)
print (ho)
print (Q_prom)

"""# Determinacion de la cantidad de horquillas

# Caida de presion
"""

print ("Area disponible por horquilla: ", Area_transf_disp_horquilla)

# Calcular la cantidad de horquillas
cant_horquillas = Area_req / Area_transf_disp_horquilla
print("Cantidad de horquillas calculadas:", cant_horquillas)


# Calcular el valor entero más cercano
entero_mas_cercano = math.floor(cant_horquillas)  # Valor entero más cercano hacia abajo

# Calcular el exceso respecto al valor entero más cercano
exceso = cant_horquillas - entero_mas_cercano

# Si el exceso es mayor o igual al 5%, redondeamos hacia arriba
if exceso >= 0.05:
    cant_horquillas_redondeadas = math.ceil(cant_horquillas)
else:
    cant_horquillas_redondeadas = entero_mas_cercano  # No redondeamos si el exceso es menor al 5%

print("Cantidad de horquillas requeridas (considerando el exceso):", cant_horquillas_redondeadas)
print ()


Area_total_disponible = cant_horquillas_redondeadas * Area_transf_disp_horquilla
print ("------- AREA REQUERIDA Y AREA DISPONIBLE --------------------")
print ("Area requerida: ", Area_req)
print ("Area total disponible: ", Area_total_disponible)
Exceso_area_disponible = ((Area_total_disponible-Area_req)/Area_req)*100
print(f"Exceso de área disponible: {Exceso_area_disponible.magnitude:.2f}%")

# ================================================================================================================
# CÁLCULO DE PÉRDIDAS DE CARGA CON LÍMITES ADMISIBLES - propuesto x deepseek
# ================================================================================================================

from fluids.friction import friction_factor

# 1. Convertir las presiones admisibles a kPa (unidades consistentes con el cálculo)
deltaP_max_admisible_int = Q(0.69, 'kgf/cm**2').to('kPa')  # Lado tubos interior
deltaP_max_admisible_ext = Q(0.69, 'kgf/cm**2').to('kPa')  # Lado exterior/anular

print(f"\nPresiones admisibles convertidas:")
print(f"Tubo interior: {deltaP_max_admisible_int:.2f}")
print(f"Espacio anular: {deltaP_max_admisible_ext:.2f}")

# 2. Pérdidas de carga en el tubo interior (fluido frío - agua)
# ----------------------------------------------------------------------------
L_total_int = cant_horquillas_redondeadas * 2 * longitud_tubos # Longitud total de tubería
epsilon = 0.000045  # Rugosidad para acero comercial en metros (0.045 mm)

# Cálculo del factor de fricción usando la correlación de Churchill
fD_int = friction_factor(Re=Re_int.magnitude, eD=epsilon/dint_tubo_interior.magnitude)

# Pérdidas por fricción (ecuación de Darcy-Weisbach)
deltaP_friccion_int = (fD_int * (L_total_int/dint_tubo_interior) * (dens_c * velocidad_corregida**2)/2).to('kPa')

# Pérdidas en los retornos (4 velocidades por horquilla)
n_retornos = cant_horquillas_redondeadas * 2  # Cada horquilla tiene 2 retornos
deltaP_retornos_int = (n_retornos * 0.5 * dens_c * velocidad_corregida**2).to('kPa')

# Pérdida total en el tubo interior
deltaP_total_int = deltaP_friccion_int + deltaP_retornos_int

# 3. Pérdidas de carga en el espacio anular (fluido caliente - gas)
# ----------------------------------------------------------------------------
# Diámetro hidráulico para el espacio anular
Dh_anular = dint_tubo_exterior - dext_tubo_interior

# Cálculo del factor de fricción para el anular
fD_ext = friction_factor(Re=Re_ext.magnitude, eD=epsilon/Dh_anular.magnitude)

# Longitud total para el fluido caliente (misma que para el frío)
L_total_ext = L_total_int

# Pérdidas por fricción en el anular
deltaP_friccion_ext = (fD_ext * (L_total_ext/Dh_anular) * (dens_h * veloc_ext**2)/2).to('kPa')

# Pérdidas en los retornos (estimación conservadora)
deltaP_retornos_ext = (n_retornos * 1.0 * dens_h * veloc_ext**2).to('kPa')  # Factor 1.0 para retornos en anular

# Pérdida total en el espacio anular
deltaP_total_ext = deltaP_friccion_ext + deltaP_retornos_ext

# 4. Resultados detallados con comparación contra admisibles
# ----------------------------------------------------------------------------
print("\n" + "="*80)
print("RESULTADOS DE PÉRDIDAS DE CARGA".center(80))
print("="*80)

print("\nTUBO INTERIOR: ", nombre_fluido_frio)
print(f"- Pérdidas por fricción: {deltaP_friccion_int:.3f}")
print(f"- Pérdidas en retornos: {deltaP_retornos_int:.3f}")
print(f"- PÉRDIDA TOTAL: {deltaP_total_int:.3f}")
print(f"- LÍMITE ADMISIBLE: {deltaP_max_admisible_int:.3f}")
print(f"- MARGEN: {(deltaP_max_admisible_int - deltaP_total_int):.3f} ({((deltaP_max_admisible_int - deltaP_total_int)/deltaP_max_admisible_int*100):.1f}%)")
print("- ESTADO: " + ("✅ DENTRO DE LÍMITE" if deltaP_total_int <= deltaP_max_admisible_int else "❌ EXCEDE LÍMITE"))

print("\nESPACIO ANULAR: ", nombre_fluido_caliente)
print(f"- Pérdidas por fricción: {deltaP_friccion_ext:.3f}")
print(f"- Pérdidas en retornos: {deltaP_retornos_ext:.3f}")
print(f"- PÉRDIDA TOTAL: {deltaP_total_ext:.3f}")
print(f"- LÍMITE ADMISIBLE: {deltaP_max_admisible_ext:.3f}")
print(f"- MARGEN: {(deltaP_max_admisible_ext - deltaP_total_ext):.3f} ({((deltaP_max_admisible_ext - deltaP_total_ext)/deltaP_max_admisible_ext*100):.1f}%)")
print("- ESTADO: " + ("✅ DENTRO DE LÍMITE" if deltaP_total_ext <= deltaP_max_admisible_ext else "❌ EXCEDE LÍMITE"))

# 5. Recomendaciones si se exceden los límites
# ----------------------------------------------------------------------------
if deltaP_total_int > deltaP_max_admisible_int or deltaP_total_ext > deltaP_max_admisible_ext:
    print("\n¡ADVERTENCIA! Se exceden los límites de pérdida de presión:")

    if deltaP_total_int > deltaP_max_admisible_int:
        print(f"- Tubo interior excede en {(deltaP_total_int - deltaP_max_admisible_int):.3f}")
        print("❌  Optimizacion requerida:")



    if deltaP_total_ext > deltaP_max_admisible_ext:
        print(f"- Espacio anular excede en {(deltaP_total_ext - deltaP_max_admisible_ext):.3f}")
        print("❌ optimizacion requerida:")

else:
    print("\n¡DISEÑO ACEPTABLE! Todas las pérdidas están dentro de los límites admisibles.")

"""# Sección nueva"""